# CW1. QuickSort. Ткаченко Егор Андреевич

[Параллельная реализация (как на лекции с filter)](parallel/parallel.go)

[Параллельная реализация (не канон, зато быстрее)](good_parallel/good_parallel.go)

[Последовательная реализация](sequential/sequentioal.go)

[Бенчмарк для сравнения (с проверкой корректности)](qsort_test.go)

Результат запуска с командой `go test -bench=. -benchtime=1x -benchmem -cpu=4`:
```
goos: linux
goarch: amd64
pkg: quicksort
cpu: AMD Ryzen 7 5800X3D 8-Core Processor           
BenchmarkQuickSorter/Par(filter)-4  41559638798 ns/op   170493131616 B/op      26145 allocs/op
BenchmarkQuickSorter/Par(good)-4    12312718448 ns/op          44816 B/op        641 allocs/op
BenchmarkQuickSorter/Seq-4          37087330847 ns/op              0 B/op          0 allocs/op
PASS
ok      quicksort       138.075s
```

Par(good) vs Seq 37087330847ns÷12312718448ns = 3.012\
неканоничное решение в ~3 раза быстрее последовательного

Seq vs Par(filter) 41559638798÷37087330847 = 1.12\
каноничное решение с лекции в 1.12 раза медленнее последовательного

Вывод:

Мне не получилось добиться ускорения QuickSort каноничным методом с лекции из-за увеличенного work: лишние аллокации (даже после попыток оптимизации), лишние перемещения элементов в памяти, лишние вызовы функций, очень частый спавн корутин (по сравнению со следующим решением).

Однако, более простая параллелизация позволила ускорить алгоритм в 3 раза, т.к. не требует больших аллокаций (не считая чего-то небольшого для корутин) и все созданные корутины использовались эффективнее.